# -*- coding: utf-8 -*-
"""2.10-OO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zvhoMrfCXxwEU6PTCU0JHF80-1PBo8b5

> Projeto Desenvolve <br>
Programação Intermediária com Python <br>
Profa. Camila Laranjeira (mila@projetodesenvolve.com.br) <br>

# 2.5 a 2.10 - Pilares da OO

## Exercícios

#### Q1.
Essa lista de exercícios terá como base a classe `Evento` criada em exercícios anteriores. Primeiramente criaremos a classe abstrata `EventoABC` com os métodos de instância abstratos `__str__(self)` e `isConcluido(self)`, indicando que todos as subclasses que dela herdarem devem implementar esses métodos.

`EventoABC` também possui os atributos `_titulo` (string) e `_descricao` (string), cujos valores são recebidos e inicializados no construtor da classe. Note a convenção de nomenclatura indicando o caráter privado desses atributos.
"""

#### Classe EventoABC
from abc import ABC, abstractmethod

class EventoABC(ABC):
    def __init__(self, titulo: str, descricao: str):
        self._titulo = titulo
        self._descricao = descricao

    @abstractmethod
    def __str__(self):
        """Retorna a representação em string do evento."""
        pass

    @abstractmethod
    def isConcluido(self):
        """Retorna True se o evento estiver concluído."""
        pass

"""#### Q2.

Crie a classe `DataHora` que dará suporte ao registro de eventos de calendário.
* A classe possui o atributo de instância `_data_hora` (datetime) privado e um atributo de classe `FORMAT` inicializado com a formatação de string aceito para `_data_hora`, ou seja, `FORMAT = '%d/%m/%Y, %H:%M'`.
* A classe **não possui construtor customizado**. A alteração de seu atributo se dará a partir da propriedade a seguir.
* Crie a `property` `data_hora` para manipular o atributo `_data_hora`.
    * O getter da propriedade deve retornar a data como uma string formatada (`%d/%m/%Y, %H:%M`). Use o atributo `FORMAT`. Consulte o [funcionamento do método `strftime`](https://www.programiz.com/python-programming/datetime/strftime).
    * O setter da propriedade deve receber uma string de data formatada (`%d/%m/%Y, %H:%M`) e implementar um bloco try-except que tenta converter a string em `datetime` e lança um `ValueError` caso a entrada seja inválida. Use o atributo `FORMAT`. Consulte o [funcionamento do método `strptime`](https://www.digitalocean.com/community/tutorials/python-string-to-datetime-strptime).
* Crie o método de instância `isPassado(self)` que avalia se a `_data_hora` é menor que `datetime.now()` (a data e hora atual) e retorna `True` em caso positivo, e `False` caso contrário.
* Crie o método de instância `somaDias(self, num_dias)` que recebe um inteiro `num_dias`, soma esse valor ao atributo interno `_data_hora` e retorna a string formatada do resultado da soma (código dado a seguir).   
```python
data_hora_somada = self._data_hora + datetime.timedelta(days=num_dias)
return data_hora_somada.strftime(FORMAT)
```

Teste a classe `DataHora` com o seguinte código (altere o que for necessário):
```python
# instanciando o objeto
dh = DataHora()

# definindo a data_hora através da propriedade
dh.data_hora = '05/02/2024, 12:30'

## editando a data_hora através da função somaDias
dh.data_hora = dh.somaDias(30)

## imprimindo a data_hora editada e se é passado
print(dh.data_hora, dh.isPassado())
```
"""

#### Classe DataHora
from abc import ABC, abstractmethod

class EventoABC(ABC):
    def __init__(self, titulo: str, descricao: str):
        self._titulo = titulo
        self._descricao = descricao

    @abstractmethod
    def __str__(self):
        """Retorna uma representação em string do evento."""
        pass

    @abstractmethod
    def isConcluido(self):
        """Retorna True se o evento está concluído, False caso contrário."""
        pass

"""#### Q3.
Crie a classe `EventoUnico`:
* A classe deve herdar de `EventoABC`.
* Possui o atributo de instância `_data_hora` (classe `DataHora` que criamos previamente).
* Seu construtor deve receber e inicializar os atributos da superclasse, além do valor de `_data_hora` recebido como uma string formatada (`%d/%m/%Y, %H:%M`). Note que para alterar `_data_hora` (objeto tipo `DataHora`), você deve manipular a propriedade interna da classe.
*  Implementa os métodos abstratos da superclasse:
    * Método `isConcluido()` que invoca o método `isPassado()` de `_data_hora` e retorna o seu resultado.
    * Método `__str__` que imprime os atributos do evento na forma `"Evento: _titulo, Data: _data_hora, Descrição: _descricao, Concluido: isConcluido()"`. Note que `isConcluido()` é o método de avaliação implementado.
* Crie o método de instância `editar_data_hora` que recebe uma string formatada e altera `_data_hora` (através de sua propriedade interna).
    
    
Teste a classe `EventoUnico` com o seguinte código:
```python
# criar evento
evento = EventoUnico('Reunião', 'Sala 302, prédio da esquina', '05/10/2023, 16:30')
print(evento)

# editar data do evento (através da propriedade)
evento.editar_data_hora('05/10/2024, 16:30')
print(evento)
```
"""

#### Classe EventoUnico
from datetime import datetime, timedelta

class DataHora:
    FORMAT = '%d/%m/%Y, %H:%M'

    def __init__(self):
        self._data_hora = None   # sem construtor customizado, começa vazio

    @property
    def data_hora(self):
        """Retorna a data/hora formatada como string."""
        if self._data_hora is None:
            return None
        return self._data_hora.strftime(self.FORMAT)

    @data_hora.setter
    def data_hora(self, data_str):
        """Recebe string, converte para datetime e valida."""
        try:
            self._data_hora = datetime.strptime(data_str, self.FORMAT)
        except Exception:
            raise ValueError(f"Data inválida! Use o formato {self.FORMAT}")

    def isPassado(self):
        """Retorna True se a data já passou."""
        if self._data_hora is None:
            return False
        return self._data_hora < datetime.now()

    def somaDias(self, num_dias):
        """Soma dias à data atual e retorna string formatada."""
        if self._data_hora is None:
            raise ValueError("Defina data_hora antes de usar somaDias.")

        data_hora_somad

"""#### Q3.
Crie a classe `EventoRecorrente`:
* A classe deve herdar de `EventoABC`.
* Possui como atributo próprio uma lista privada de objetos `DataHora` (como você deve nomear o atributo?).
* Seu construtor recebe os atributos da superclasse, além dos atributos `data_hora_inicial` (string formatada), `data_hora_final` (string formatada) e `intervalo_repeticao` (int), sendo o intervalo dado em dias. Preencha a coleção `DataHora` de acordo com o intervalo de repetição fornecido. Dica: crie o objeto `DataHora` inicial e use sua função interna `somaDias` para criar iterativamente as novas instâncias do intervalo até chegar em `DataHora` final.
*  Implementa os métodos abstratos da superclasse:
    * Método `isConcluido(indice)` que que invoca o método `isPassado()` do elemento `indice` da coleção de objetos `DataHora` e retorna seu resultado.
    * Método `__str__` que imprime (em um laço) **todos as ocorrências `i` do evento** na forma `"Evento: _titulo, Data: data_hora[i], Descrição: _descricao, Concluido: isConcluido(i)"`.
* Crie o método `editar_data_hora` que recebe `data_hora_antiga` e `data_hora_nova` e altera o elemento da coleção de objetos `DataHora` que corresponde a `data_hora_antiga` fornecida.    


Teste a classe `EventoRecorrente` com o seguinte código:
```python
# criar evento
eventos = EventoRecorrente(
    'Reunião', 'Sala 302, prédio da esquina',
    '05/01/2024, 16:30', '05/01/2025, 16:30', 30)

# imprimir eventos
print(eventos)

# editar um dos eventos
eventos.editar_data_hora('05/12/2024, 16:30', '05/12/2024, 11:30')

# imprimir eventos
print(eventos)
```
"""

class EventoUnico(EventoABC):
    def __init__(self, titulo, descricao, data_hora_str):
        super().__init__(titulo, descricao)
        self._data_hora = DataHora()       # cria o objeto DataHora
        self._data_hora.data_hora = data_hora_str  # usa a property para configurar a data

    def isConcluido(self):
        """Retorna True se a data do evento já passou."""
        return self._data_hora.isPassado()

    def __str__(self):
        return (f"Evento: {self._titulo}, Data: {self._data_hora.data_hora}, "
                f"Descrição: {self._descricao}, Concluido: {self.isConcluido()}")

    def editar_data_hora(self, nova_data_str):
        """Altera a data/hora usando a property da classe DataHora."""
        self._data_hora.data_hora = nova_data_str

"""#### Q4.

Por fim, vamos só ver o polimorfismo em ação. Crie e preencha uma lista de eventos, sendo alguns do tipo `EventoUnico` e outros do tipo `EventoRecorrente`. Sobre essa lista, execute o laço de impressão a seguir:
```python
for evento in lista_eventos: print(evento)
```
A função `print` irá invocar o método especial `__str__` das classes correspondentes dependendo do tipo do objeto recebido. Aí está o polimorfismo :)
"""

# Criando alguns eventos únicos
class EventoRecorrente(EventoABC):
    def __init__(self, titulo, descricao,
                 data_hora_inicial, data_hora_final,
                 intervalo_repeticao):

        super().__init__(titulo, descricao)

        self._datas = []  # lista privada

        # DataHora inicial
        dh_inicial = DataHora()
        dh_inicial.data_hora = data_hora_inicial

        # DataHora final
        dh_final = DataHora()
        dh_final.data_hora = data_hora_final

        # adiciona a primeira
        self._datas.append(dh_inicial)

        atual = dh_inicial
        while True:
            proxima = atual.somaDias(intervalo_repeticao)

            novo_obj = DataHora()
            novo_obj.data_hora = proxima

            if novo_obj._data_hora > dh_final._data_hora:
                break

            self._datas.append(novo_obj)
            atual = novo_obj

    def isConcluido(self, indice):
        return self._datas[indice].isPassado()

    def __str__(self):
        texto = ""
        for i, dh in enumerate(self._datas):
            texto += (
                f"Evento: {self._titulo}, Data: {dh.data_hora}, "
                f"Descrição: {self._descricao}, "
                f"Concluido: {self.isConcluido(i)}\n"
            )
        return texto

    def editar_data_hora(self, antiga, nova):
        for dh in self._datas:
            if dh.data_hora == antiga:
                dh.data_hora = nova
                return
        raise ValueError("Data antiga não encontrada.")